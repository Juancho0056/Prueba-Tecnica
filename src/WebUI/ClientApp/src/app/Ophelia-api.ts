/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IArticuloClient {
    create(command: CreateArticuloRequest): Observable<ProblemDetails>;
    update(command: UpdateArticuloRequest): Observable<ProblemDetails>;
    delete(command: DeleteArticuloRequest): Observable<ProblemDetails>;
    getAll(id: number | null | undefined, detalle: string | null | undefined, unidadId: number | null | undefined, estadoRegistro: boolean | null | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<ArticuloExistenciaDto>;
    get(id: number | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<ArticuloDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ArticuloClient implements IArticuloClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(command: CreateArticuloRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/Articulo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    update(command: UpdateArticuloRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/Articulo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    delete(command: DeleteArticuloRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/Articulo/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    getAll(id: number | null | undefined, detalle: string | null | undefined, unidadId: number | null | undefined, estadoRegistro: boolean | null | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<ArticuloExistenciaDto> {
        let url_ = this.baseUrl + "/api/Articulo/GetAll?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (detalle !== undefined)
            url_ += "Detalle=" + encodeURIComponent("" + detalle) + "&"; 
        if (unidadId !== undefined)
            url_ += "UnidadId=" + encodeURIComponent("" + unidadId) + "&"; 
        if (estadoRegistro !== undefined)
            url_ += "EstadoRegistro=" + encodeURIComponent("" + estadoRegistro) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ArticuloExistenciaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ArticuloExistenciaDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ArticuloExistenciaDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ArticuloExistenciaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(id: number | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<ArticuloDto> {
        let url_ = this.baseUrl + "/api/Articulo/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ArticuloDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ArticuloDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ArticuloDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ArticuloDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IClienteClient {
    create(command: CreateClienteRequest): Observable<ProblemDetails>;
    update(command: UpdateClienteRequest): Observable<ProblemDetails>;
    delete(command: DeleteClienteRequest): Observable<ProblemDetails>;
    getAll(id: number | null | undefined, tipoDocumentoId: string | null | undefined, nroDocumento: string | null | undefined, primerNombre: string | null | undefined, segundoNombre: string | null | undefined, fechaNacimiento: Date | null | undefined, estadoRegistro: boolean | null | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<ClienteDto>;
    get(id: number | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<ClienteDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ClienteClient implements IClienteClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(command: CreateClienteRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/Cliente/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    update(command: UpdateClienteRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/Cliente/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    delete(command: DeleteClienteRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/Cliente/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    getAll(id: number | null | undefined, tipoDocumentoId: string | null | undefined, nroDocumento: string | null | undefined, primerNombre: string | null | undefined, segundoNombre: string | null | undefined, fechaNacimiento: Date | null | undefined, estadoRegistro: boolean | null | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<ClienteDto> {
        let url_ = this.baseUrl + "/api/Cliente/GetAll?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (tipoDocumentoId !== undefined)
            url_ += "TipoDocumentoId=" + encodeURIComponent("" + tipoDocumentoId) + "&"; 
        if (nroDocumento !== undefined)
            url_ += "NroDocumento=" + encodeURIComponent("" + nroDocumento) + "&"; 
        if (primerNombre !== undefined)
            url_ += "PrimerNombre=" + encodeURIComponent("" + primerNombre) + "&"; 
        if (segundoNombre !== undefined)
            url_ += "SegundoNombre=" + encodeURIComponent("" + segundoNombre) + "&"; 
        if (fechaNacimiento !== undefined)
            url_ += "FechaNacimiento=" + encodeURIComponent(fechaNacimiento ? "" + fechaNacimiento.toJSON() : "") + "&"; 
        if (estadoRegistro !== undefined)
            url_ += "EstadoRegistro=" + encodeURIComponent("" + estadoRegistro) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ClienteDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClienteDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ClienteDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClienteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(id: number | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<ClienteDto> {
        let url_ = this.baseUrl + "/api/Cliente/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ClienteDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClienteDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClienteDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClienteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface ITipoDocumentoClient {
    create(command: CreateTipoDocumentoRequest): Observable<ProblemDetails>;
    update(command: UpdateTipoDocumentoRequest): Observable<ProblemDetails>;
    delete(command: DeleteTipoDocumentoRequest): Observable<ProblemDetails>;
    getAll(id: string | null | undefined, detalle: string | null | undefined, estadoRegistro: boolean | null | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<TipoDocumentoDto>;
    get(id: string | null | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<TipoDocumentoDto>;
}

@Injectable({
    providedIn: 'root'
})
export class TipoDocumentoClient implements ITipoDocumentoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(command: CreateTipoDocumentoRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/TipoDocumento/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    update(command: UpdateTipoDocumentoRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/TipoDocumento/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    delete(command: DeleteTipoDocumentoRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/TipoDocumento/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    getAll(id: string | null | undefined, detalle: string | null | undefined, estadoRegistro: boolean | null | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<TipoDocumentoDto> {
        let url_ = this.baseUrl + "/api/TipoDocumento/GetAll?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (detalle !== undefined)
            url_ += "Detalle=" + encodeURIComponent("" + detalle) + "&"; 
        if (estadoRegistro !== undefined)
            url_ += "EstadoRegistro=" + encodeURIComponent("" + estadoRegistro) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TipoDocumentoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TipoDocumentoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoDocumentoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoDocumentoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(id: string | null | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<TipoDocumentoDto> {
        let url_ = this.baseUrl + "/api/TipoDocumento/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TipoDocumentoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TipoDocumentoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TipoDocumentoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoDocumentoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IUnidadClient {
    create(command: CreateUnidadRequest): Observable<ProblemDetails>;
    update(command: UpdateUnidadRequest): Observable<ProblemDetails>;
    delete(command: DeleteUnidadRequest): Observable<ProblemDetails>;
    getAll(id: number | undefined, detalle: string | null | undefined, estadoRegistro: boolean | null | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<UnidadDto>;
    get(id: number | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<UnidadDto>;
}

@Injectable({
    providedIn: 'root'
})
export class UnidadClient implements IUnidadClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(command: CreateUnidadRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/Unidad/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    update(command: UpdateUnidadRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/Unidad/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    delete(command: DeleteUnidadRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/Unidad/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    getAll(id: number | undefined, detalle: string | null | undefined, estadoRegistro: boolean | null | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<UnidadDto> {
        let url_ = this.baseUrl + "/api/Unidad/GetAll?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (detalle !== undefined)
            url_ += "Detalle=" + encodeURIComponent("" + detalle) + "&"; 
        if (estadoRegistro !== undefined)
            url_ += "EstadoRegistro=" + encodeURIComponent("" + estadoRegistro) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<UnidadDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnidadDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UnidadDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnidadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(id: number | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<UnidadDto> {
        let url_ = this.baseUrl + "/api/Unidad/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UnidadDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnidadDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UnidadDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnidadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface IVentaClient {
    create(command: CreateVentaRequest): Observable<ProblemDetails>;
    delete(command: DeleteVentaRequest): Observable<ProblemDetails>;
    getAll(id: number | undefined, fechaVenta: Date | undefined, clienteId: number | undefined, estadoRegistro: boolean | null | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<VentaDto>;
    get(id: number | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<VentaDto>;
}

@Injectable({
    providedIn: 'root'
})
export class VentaClient implements IVentaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(command: CreateVentaRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/Venta/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    delete(command: DeleteVentaRequest): Observable<ProblemDetails> {
        let url_ = this.baseUrl + "/api/Venta/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ProblemDetails>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProblemDetails>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ProblemDetails> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return _observableOf(resultdefault);
            }));
        }
    }

    getAll(id: number | undefined, fechaVenta: Date | undefined, clienteId: number | undefined, estadoRegistro: boolean | null | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<VentaDto> {
        let url_ = this.baseUrl + "/api/Venta/GetAll?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (fechaVenta === null)
            throw new Error("The parameter 'fechaVenta' cannot be null.");
        else if (fechaVenta !== undefined)
            url_ += "FechaVenta=" + encodeURIComponent(fechaVenta ? "" + fechaVenta.toJSON() : "") + "&"; 
        if (clienteId === null)
            throw new Error("The parameter 'clienteId' cannot be null.");
        else if (clienteId !== undefined)
            url_ += "ClienteId=" + encodeURIComponent("" + clienteId) + "&"; 
        if (estadoRegistro !== undefined)
            url_ += "EstadoRegistro=" + encodeURIComponent("" + estadoRegistro) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<VentaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VentaDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VentaDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VentaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(id: number | undefined, page: number | undefined, limit: number | undefined, sort: string[] | null | undefined): Observable<VentaDto> {
        let url_ = this.baseUrl + "/api/Venta/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&"; 
        if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<VentaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VentaDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<VentaDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VentaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        this.extensions![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    data["extensions"][key] = this.extensions[key];
            }
        }
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export abstract class CommandRequestOfArticuloExistenciaDto implements ICommandRequestOfArticuloExistenciaDto {

    constructor(data?: ICommandRequestOfArticuloExistenciaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CommandRequestOfArticuloExistenciaDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CommandRequestOfArticuloExistenciaDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ICommandRequestOfArticuloExistenciaDto {
}

export class CreateArticuloRequest extends CommandRequestOfArticuloExistenciaDto implements ICreateArticuloRequest {
    articulo!: ArticuloRequest;
    existenciaMinima!: number;
    existenciaMaxima!: number;
    cantDisponible!: number;

    constructor(data?: ICreateArticuloRequest) {
        super(data);
        if (!data) {
            this.articulo = new ArticuloRequest();
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.articulo = _data["articulo"] ? ArticuloRequest.fromJS(_data["articulo"]) : new ArticuloRequest();
            this.existenciaMinima = _data["existenciaMinima"];
            this.existenciaMaxima = _data["existenciaMaxima"];
            this.cantDisponible = _data["cantDisponible"];
        }
    }

    static fromJS(data: any): CreateArticuloRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateArticuloRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["articulo"] = this.articulo ? this.articulo.toJSON() : <any>undefined;
        data["existenciaMinima"] = this.existenciaMinima;
        data["existenciaMaxima"] = this.existenciaMaxima;
        data["cantDisponible"] = this.cantDisponible;
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateArticuloRequest extends ICommandRequestOfArticuloExistenciaDto {
    articulo: ArticuloRequest;
    existenciaMinima: number;
    existenciaMaxima: number;
    cantDisponible: number;
}

export class ArticuloRequest implements IArticuloRequest {
    detalle!: string;
    unidadId?: number;
    precio?: number;

    constructor(data?: IArticuloRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.detalle = _data["detalle"];
            this.unidadId = _data["unidadId"];
            this.precio = _data["precio"];
        }
    }

    static fromJS(data: any): ArticuloRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ArticuloRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["detalle"] = this.detalle;
        data["unidadId"] = this.unidadId;
        data["precio"] = this.precio;
        return data; 
    }
}

export interface IArticuloRequest {
    detalle: string;
    unidadId?: number;
    precio?: number;
}

export class UpdateArticuloRequest extends CommandRequestOfArticuloExistenciaDto implements IUpdateArticuloRequest {
    id!: number;
    articulo!: ArticuloRequest2;
    existenciaMinima!: number;
    existenciaMaxima!: number;
    cantDisponible!: number;
    estadoRegistro?: boolean | undefined;

    constructor(data?: IUpdateArticuloRequest) {
        super(data);
        if (!data) {
            this.articulo = new ArticuloRequest2();
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.articulo = _data["articulo"] ? ArticuloRequest2.fromJS(_data["articulo"]) : new ArticuloRequest2();
            this.existenciaMinima = _data["existenciaMinima"];
            this.existenciaMaxima = _data["existenciaMaxima"];
            this.cantDisponible = _data["cantDisponible"];
            this.estadoRegistro = _data["estadoRegistro"];
        }
    }

    static fromJS(data: any): UpdateArticuloRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateArticuloRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["articulo"] = this.articulo ? this.articulo.toJSON() : <any>undefined;
        data["existenciaMinima"] = this.existenciaMinima;
        data["existenciaMaxima"] = this.existenciaMaxima;
        data["cantDisponible"] = this.cantDisponible;
        data["estadoRegistro"] = this.estadoRegistro;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateArticuloRequest extends ICommandRequestOfArticuloExistenciaDto {
    id: number;
    articulo: ArticuloRequest2;
    existenciaMinima: number;
    existenciaMaxima: number;
    cantDisponible: number;
    estadoRegistro?: boolean | undefined;
}

export class ArticuloRequest2 implements IArticuloRequest2 {
    id!: number;
    detalle!: string;
    unidadId?: number;
    precio?: number;
    estadoRegistro?: boolean | undefined;

    constructor(data?: IArticuloRequest2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.detalle = _data["detalle"];
            this.unidadId = _data["unidadId"];
            this.precio = _data["precio"];
            this.estadoRegistro = _data["estadoRegistro"];
        }
    }

    static fromJS(data: any): ArticuloRequest2 {
        data = typeof data === 'object' ? data : {};
        let result = new ArticuloRequest2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["detalle"] = this.detalle;
        data["unidadId"] = this.unidadId;
        data["precio"] = this.precio;
        data["estadoRegistro"] = this.estadoRegistro;
        return data; 
    }
}

export interface IArticuloRequest2 {
    id: number;
    detalle: string;
    unidadId?: number;
    precio?: number;
    estadoRegistro?: boolean | undefined;
}

export class DeleteArticuloRequest extends CommandRequestOfArticuloExistenciaDto implements IDeleteArticuloRequest {
    id!: number;

    constructor(data?: IDeleteArticuloRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteArticuloRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteArticuloRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IDeleteArticuloRequest extends ICommandRequestOfArticuloExistenciaDto {
    id: number;
}

export abstract class AuditableEntity implements IAuditableEntity {
    estadoRegistro?: boolean;
    creadoPor?: string | undefined;
    fechaCreacion?: Date;
    modificadoPor?: string | undefined;
    fechaModificacion?: Date | undefined;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.estadoRegistro = _data["estadoRegistro"];
            this.creadoPor = _data["creadoPor"];
            this.fechaCreacion = _data["fechaCreacion"] ? new Date(_data["fechaCreacion"].toString()) : <any>undefined;
            this.modificadoPor = _data["modificadoPor"];
            this.fechaModificacion = _data["fechaModificacion"] ? new Date(_data["fechaModificacion"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["estadoRegistro"] = this.estadoRegistro;
        data["creadoPor"] = this.creadoPor;
        data["fechaCreacion"] = this.fechaCreacion ? this.fechaCreacion.toISOString() : <any>undefined;
        data["modificadoPor"] = this.modificadoPor;
        data["fechaModificacion"] = this.fechaModificacion ? this.fechaModificacion.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAuditableEntity {
    estadoRegistro?: boolean;
    creadoPor?: string | undefined;
    fechaCreacion?: Date;
    modificadoPor?: string | undefined;
    fechaModificacion?: Date | undefined;
}

export class ArticuloExistenciaDto extends AuditableEntity implements IArticuloExistenciaDto {
    id?: number;
    articulo?: ArticuloDto | undefined;
    existenciaMinima?: number;
    existenciaMaxima?: number;
    cantDisponible?: number;

    constructor(data?: IArticuloExistenciaDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.articulo = _data["articulo"] ? ArticuloDto.fromJS(_data["articulo"]) : <any>undefined;
            this.existenciaMinima = _data["existenciaMinima"];
            this.existenciaMaxima = _data["existenciaMaxima"];
            this.cantDisponible = _data["cantDisponible"];
        }
    }

    static fromJS(data: any): ArticuloExistenciaDto {
        data = typeof data === 'object' ? data : {};
        let result = new ArticuloExistenciaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["articulo"] = this.articulo ? this.articulo.toJSON() : <any>undefined;
        data["existenciaMinima"] = this.existenciaMinima;
        data["existenciaMaxima"] = this.existenciaMaxima;
        data["cantDisponible"] = this.cantDisponible;
        super.toJSON(data);
        return data; 
    }
}

export interface IArticuloExistenciaDto extends IAuditableEntity {
    id?: number;
    articulo?: ArticuloDto | undefined;
    existenciaMinima?: number;
    existenciaMaxima?: number;
    cantDisponible?: number;
}

export class ArticuloDto extends AuditableEntity implements IArticuloDto {
    id?: number;
    detalle?: string | undefined;
    unidadDetalle?: string | undefined;
    unidadId?: number;
    unidad?: UnidadDto | undefined;
    precio?: number;

    constructor(data?: IArticuloDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.detalle = _data["detalle"];
            this.unidadDetalle = _data["unidadDetalle"];
            this.unidadId = _data["unidadId"];
            this.unidad = _data["unidad"] ? UnidadDto.fromJS(_data["unidad"]) : <any>undefined;
            this.precio = _data["precio"];
        }
    }

    static fromJS(data: any): ArticuloDto {
        data = typeof data === 'object' ? data : {};
        let result = new ArticuloDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["detalle"] = this.detalle;
        data["unidadDetalle"] = this.unidadDetalle;
        data["unidadId"] = this.unidadId;
        data["unidad"] = this.unidad ? this.unidad.toJSON() : <any>undefined;
        data["precio"] = this.precio;
        super.toJSON(data);
        return data; 
    }
}

export interface IArticuloDto extends IAuditableEntity {
    id?: number;
    detalle?: string | undefined;
    unidadDetalle?: string | undefined;
    unidadId?: number;
    unidad?: UnidadDto | undefined;
    precio?: number;
}

export class UnidadDto extends AuditableEntity implements IUnidadDto {
    id?: number;
    detalle?: string | undefined;

    constructor(data?: IUnidadDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.detalle = _data["detalle"];
        }
    }

    static fromJS(data: any): UnidadDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnidadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["detalle"] = this.detalle;
        super.toJSON(data);
        return data; 
    }
}

export interface IUnidadDto extends IAuditableEntity {
    id?: number;
    detalle?: string | undefined;
}

export abstract class CommandRequestOfClienteDto implements ICommandRequestOfClienteDto {

    constructor(data?: ICommandRequestOfClienteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CommandRequestOfClienteDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CommandRequestOfClienteDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ICommandRequestOfClienteDto {
}

export class CreateClienteRequest extends CommandRequestOfClienteDto implements ICreateClienteRequest {
    nroDocumento!: string;
    tipoDocumentoId?: string | undefined;
    primerNombre!: string;
    segundoNombre?: string | undefined;
    fechaNacimiento?: Date | undefined;

    constructor(data?: ICreateClienteRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nroDocumento = _data["nroDocumento"];
            this.tipoDocumentoId = _data["tipoDocumentoId"];
            this.primerNombre = _data["primerNombre"];
            this.segundoNombre = _data["segundoNombre"];
            this.fechaNacimiento = _data["fechaNacimiento"] ? new Date(_data["fechaNacimiento"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateClienteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClienteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nroDocumento"] = this.nroDocumento;
        data["tipoDocumentoId"] = this.tipoDocumentoId;
        data["primerNombre"] = this.primerNombre;
        data["segundoNombre"] = this.segundoNombre;
        data["fechaNacimiento"] = this.fechaNacimiento ? this.fechaNacimiento.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateClienteRequest extends ICommandRequestOfClienteDto {
    nroDocumento: string;
    tipoDocumentoId?: string | undefined;
    primerNombre: string;
    segundoNombre?: string | undefined;
    fechaNacimiento?: Date | undefined;
}

export class UpdateClienteRequest extends CommandRequestOfClienteDto implements IUpdateClienteRequest {
    id?: number;
    nroDocumento!: string;
    tipoDocumentoId?: string | undefined;
    primerNombre!: string;
    segundoNombre?: string | undefined;
    fechaNacimiento?: Date | undefined;
    estadoRegistro?: boolean | undefined;

    constructor(data?: IUpdateClienteRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.nroDocumento = _data["nroDocumento"];
            this.tipoDocumentoId = _data["tipoDocumentoId"];
            this.primerNombre = _data["primerNombre"];
            this.segundoNombre = _data["segundoNombre"];
            this.fechaNacimiento = _data["fechaNacimiento"] ? new Date(_data["fechaNacimiento"].toString()) : <any>undefined;
            this.estadoRegistro = _data["estadoRegistro"];
        }
    }

    static fromJS(data: any): UpdateClienteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClienteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nroDocumento"] = this.nroDocumento;
        data["tipoDocumentoId"] = this.tipoDocumentoId;
        data["primerNombre"] = this.primerNombre;
        data["segundoNombre"] = this.segundoNombre;
        data["fechaNacimiento"] = this.fechaNacimiento ? this.fechaNacimiento.toISOString() : <any>undefined;
        data["estadoRegistro"] = this.estadoRegistro;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateClienteRequest extends ICommandRequestOfClienteDto {
    id?: number;
    nroDocumento: string;
    tipoDocumentoId?: string | undefined;
    primerNombre: string;
    segundoNombre?: string | undefined;
    fechaNacimiento?: Date | undefined;
    estadoRegistro?: boolean | undefined;
}

export class DeleteClienteRequest extends CommandRequestOfClienteDto implements IDeleteClienteRequest {
    id!: number;

    constructor(data?: IDeleteClienteRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteClienteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteClienteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IDeleteClienteRequest extends ICommandRequestOfClienteDto {
    id: number;
}

export class ClienteDto extends AuditableEntity implements IClienteDto {
    id?: number;
    tipoDocumentoId?: string | undefined;
    tipoDocumento?: TipoDocumentoDto | undefined;
    tipoDocumentoDetalle?: string | undefined;
    nroDocumento?: string | undefined;
    primerNombre?: string | undefined;
    segundoNombre?: string | undefined;
    fechaNacimiento?: Date | undefined;
    nombreCliente?: string | undefined;

    constructor(data?: IClienteDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.tipoDocumentoId = _data["tipoDocumentoId"];
            this.tipoDocumento = _data["tipoDocumento"] ? TipoDocumentoDto.fromJS(_data["tipoDocumento"]) : <any>undefined;
            this.tipoDocumentoDetalle = _data["tipoDocumentoDetalle"];
            this.nroDocumento = _data["nroDocumento"];
            this.primerNombre = _data["primerNombre"];
            this.segundoNombre = _data["segundoNombre"];
            this.fechaNacimiento = _data["fechaNacimiento"] ? new Date(_data["fechaNacimiento"].toString()) : <any>undefined;
            this.nombreCliente = _data["nombreCliente"];
        }
    }

    static fromJS(data: any): ClienteDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClienteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tipoDocumentoId"] = this.tipoDocumentoId;
        data["tipoDocumento"] = this.tipoDocumento ? this.tipoDocumento.toJSON() : <any>undefined;
        data["tipoDocumentoDetalle"] = this.tipoDocumentoDetalle;
        data["nroDocumento"] = this.nroDocumento;
        data["primerNombre"] = this.primerNombre;
        data["segundoNombre"] = this.segundoNombre;
        data["fechaNacimiento"] = this.fechaNacimiento ? this.fechaNacimiento.toISOString() : <any>undefined;
        data["nombreCliente"] = this.nombreCliente;
        super.toJSON(data);
        return data; 
    }
}

export interface IClienteDto extends IAuditableEntity {
    id?: number;
    tipoDocumentoId?: string | undefined;
    tipoDocumento?: TipoDocumentoDto | undefined;
    tipoDocumentoDetalle?: string | undefined;
    nroDocumento?: string | undefined;
    primerNombre?: string | undefined;
    segundoNombre?: string | undefined;
    fechaNacimiento?: Date | undefined;
    nombreCliente?: string | undefined;
}

export class TipoDocumentoDto extends AuditableEntity implements ITipoDocumentoDto {
    id?: string | undefined;
    detalle?: string | undefined;

    constructor(data?: ITipoDocumentoDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.detalle = _data["detalle"];
        }
    }

    static fromJS(data: any): TipoDocumentoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TipoDocumentoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["detalle"] = this.detalle;
        super.toJSON(data);
        return data; 
    }
}

export interface ITipoDocumentoDto extends IAuditableEntity {
    id?: string | undefined;
    detalle?: string | undefined;
}

export abstract class CommandRequestOfTipoDocumentoDto implements ICommandRequestOfTipoDocumentoDto {

    constructor(data?: ICommandRequestOfTipoDocumentoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CommandRequestOfTipoDocumentoDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CommandRequestOfTipoDocumentoDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ICommandRequestOfTipoDocumentoDto {
}

export class CreateTipoDocumentoRequest extends CommandRequestOfTipoDocumentoDto implements ICreateTipoDocumentoRequest {
    id!: string;
    detalle!: string;

    constructor(data?: ICreateTipoDocumentoRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.detalle = _data["detalle"];
        }
    }

    static fromJS(data: any): CreateTipoDocumentoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTipoDocumentoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["detalle"] = this.detalle;
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateTipoDocumentoRequest extends ICommandRequestOfTipoDocumentoDto {
    id: string;
    detalle: string;
}

export class UpdateTipoDocumentoRequest extends CommandRequestOfTipoDocumentoDto implements IUpdateTipoDocumentoRequest {
    id?: string | undefined;
    detalle?: string | undefined;
    estadoRegistro?: boolean | undefined;

    constructor(data?: IUpdateTipoDocumentoRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.detalle = _data["detalle"];
            this.estadoRegistro = _data["estadoRegistro"];
        }
    }

    static fromJS(data: any): UpdateTipoDocumentoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTipoDocumentoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["detalle"] = this.detalle;
        data["estadoRegistro"] = this.estadoRegistro;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateTipoDocumentoRequest extends ICommandRequestOfTipoDocumentoDto {
    id?: string | undefined;
    detalle?: string | undefined;
    estadoRegistro?: boolean | undefined;
}

export class DeleteTipoDocumentoRequest extends CommandRequestOfTipoDocumentoDto implements IDeleteTipoDocumentoRequest {
    id!: string;

    constructor(data?: IDeleteTipoDocumentoRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteTipoDocumentoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTipoDocumentoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IDeleteTipoDocumentoRequest extends ICommandRequestOfTipoDocumentoDto {
    id: string;
}

export abstract class CommandRequestOfUnidadDto implements ICommandRequestOfUnidadDto {

    constructor(data?: ICommandRequestOfUnidadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CommandRequestOfUnidadDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CommandRequestOfUnidadDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ICommandRequestOfUnidadDto {
}

export class CreateUnidadRequest extends CommandRequestOfUnidadDto implements ICreateUnidadRequest {
    detalle!: string;

    constructor(data?: ICreateUnidadRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.detalle = _data["detalle"];
        }
    }

    static fromJS(data: any): CreateUnidadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUnidadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["detalle"] = this.detalle;
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateUnidadRequest extends ICommandRequestOfUnidadDto {
    detalle: string;
}

export class UpdateUnidadRequest extends CommandRequestOfUnidadDto implements IUpdateUnidadRequest {
    id?: number;
    detalle?: string | undefined;
    estadoRegistro?: boolean | undefined;

    constructor(data?: IUpdateUnidadRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.detalle = _data["detalle"];
            this.estadoRegistro = _data["estadoRegistro"];
        }
    }

    static fromJS(data: any): UpdateUnidadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUnidadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["detalle"] = this.detalle;
        data["estadoRegistro"] = this.estadoRegistro;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateUnidadRequest extends ICommandRequestOfUnidadDto {
    id?: number;
    detalle?: string | undefined;
    estadoRegistro?: boolean | undefined;
}

export class DeleteUnidadRequest extends CommandRequestOfUnidadDto implements IDeleteUnidadRequest {
    id!: number;

    constructor(data?: IDeleteUnidadRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteUnidadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteUnidadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IDeleteUnidadRequest extends ICommandRequestOfUnidadDto {
    id: number;
}

export abstract class CommandRequestOfVentaDto implements ICommandRequestOfVentaDto {

    constructor(data?: ICommandRequestOfVentaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CommandRequestOfVentaDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CommandRequestOfVentaDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ICommandRequestOfVentaDto {
}

export class CreateVentaRequest extends CommandRequestOfVentaDto implements ICreateVentaRequest {
    fechaVenta!: Date;
    clienteId!: number;
    detalles?: Detalle[] | undefined;

    constructor(data?: ICreateVentaRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fechaVenta = _data["fechaVenta"] ? new Date(_data["fechaVenta"].toString()) : <any>undefined;
            this.clienteId = _data["clienteId"];
            if (Array.isArray(_data["detalles"])) {
                this.detalles = [] as any;
                for (let item of _data["detalles"])
                    this.detalles!.push(Detalle.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateVentaRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVentaRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fechaVenta"] = this.fechaVenta ? this.fechaVenta.toISOString() : <any>undefined;
        data["clienteId"] = this.clienteId;
        if (Array.isArray(this.detalles)) {
            data["detalles"] = [];
            for (let item of this.detalles)
                data["detalles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateVentaRequest extends ICommandRequestOfVentaDto {
    fechaVenta: Date;
    clienteId: number;
    detalles?: Detalle[] | undefined;
}

export class Detalle implements IDetalle {
    articuloId!: number;
    cantidad!: number;
    valor!: number;

    constructor(data?: IDetalle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.articuloId = _data["articuloId"];
            this.cantidad = _data["cantidad"];
            this.valor = _data["valor"];
        }
    }

    static fromJS(data: any): Detalle {
        data = typeof data === 'object' ? data : {};
        let result = new Detalle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["articuloId"] = this.articuloId;
        data["cantidad"] = this.cantidad;
        data["valor"] = this.valor;
        return data; 
    }
}

export interface IDetalle {
    articuloId: number;
    cantidad: number;
    valor: number;
}

export class DeleteVentaRequest extends CommandRequestOfVentaDto implements IDeleteVentaRequest {
    id!: number;

    constructor(data?: IDeleteVentaRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteVentaRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteVentaRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data; 
    }
}

export interface IDeleteVentaRequest extends ICommandRequestOfVentaDto {
    id: number;
}

export class VentaDto extends AuditableEntity implements IVentaDto {
    id?: number;
    fechaVenta?: Date;
    cliente?: ClienteDto | undefined;
    clienteId?: number;
    nombreCliente?: string | undefined;
    vlrVenta?: number;
    detalles?: DetalleVentaDto[] | undefined;

    constructor(data?: IVentaDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.fechaVenta = _data["fechaVenta"] ? new Date(_data["fechaVenta"].toString()) : <any>undefined;
            this.cliente = _data["cliente"] ? ClienteDto.fromJS(_data["cliente"]) : <any>undefined;
            this.clienteId = _data["clienteId"];
            this.nombreCliente = _data["nombreCliente"];
            this.vlrVenta = _data["vlrVenta"];
            if (Array.isArray(_data["detalles"])) {
                this.detalles = [] as any;
                for (let item of _data["detalles"])
                    this.detalles!.push(DetalleVentaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VentaDto {
        data = typeof data === 'object' ? data : {};
        let result = new VentaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fechaVenta"] = this.fechaVenta ? this.fechaVenta.toISOString() : <any>undefined;
        data["cliente"] = this.cliente ? this.cliente.toJSON() : <any>undefined;
        data["clienteId"] = this.clienteId;
        data["nombreCliente"] = this.nombreCliente;
        data["vlrVenta"] = this.vlrVenta;
        if (Array.isArray(this.detalles)) {
            data["detalles"] = [];
            for (let item of this.detalles)
                data["detalles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IVentaDto extends IAuditableEntity {
    id?: number;
    fechaVenta?: Date;
    cliente?: ClienteDto | undefined;
    clienteId?: number;
    nombreCliente?: string | undefined;
    vlrVenta?: number;
    detalles?: DetalleVentaDto[] | undefined;
}

export class DetalleVentaDto extends AuditableEntity implements IDetalleVentaDto {
    ventaId?: number;
    venta?: VentaDto | undefined;
    articuloId?: number;
    articulo?: ArticuloDto | undefined;
    cantidad?: number;
    valor?: number;

    constructor(data?: IDetalleVentaDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.ventaId = _data["ventaId"];
            this.venta = _data["venta"] ? VentaDto.fromJS(_data["venta"]) : <any>undefined;
            this.articuloId = _data["articuloId"];
            this.articulo = _data["articulo"] ? ArticuloDto.fromJS(_data["articulo"]) : <any>undefined;
            this.cantidad = _data["cantidad"];
            this.valor = _data["valor"];
        }
    }

    static fromJS(data: any): DetalleVentaDto {
        data = typeof data === 'object' ? data : {};
        let result = new DetalleVentaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ventaId"] = this.ventaId;
        data["venta"] = this.venta ? this.venta.toJSON() : <any>undefined;
        data["articuloId"] = this.articuloId;
        data["articulo"] = this.articulo ? this.articulo.toJSON() : <any>undefined;
        data["cantidad"] = this.cantidad;
        data["valor"] = this.valor;
        super.toJSON(data);
        return data; 
    }
}

export interface IDetalleVentaDto extends IAuditableEntity {
    ventaId?: number;
    venta?: VentaDto | undefined;
    articuloId?: number;
    articulo?: ArticuloDto | undefined;
    cantidad?: number;
    valor?: number;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}